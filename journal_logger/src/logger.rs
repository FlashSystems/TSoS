use log::{Record, Level, Metadata, SetLoggerError};
use libc;

#[repr(C)]
struct iovec {
    pub iov_base: *const libc::c_void,
    pub iov_len: libc::size_t,
}

#[link(name = "systemd")]
extern "C" {
	fn sd_journal_sendv(iv: *const iovec, n: libc::c_int) -> libc::c_int;
}

/* from syslog.h */
#[repr(u8)]
enum Priority {
	//Emerg =   0, /* system is unusable */
	//Alert =   1, /* action must be taken immediately */
	//Crit =    2, /* critical conditions */
	Error =   3,   /* error conditions */
	Warning = 4,   /* warning conditions */
	//Notice =  5, /* normal but significant condition */
	Info =    6,   /* informational */
	Debug =   7    /* debug-level messages */
}

/// Implements a systemd logger
pub struct JournalLogger {
	level: Level
}

impl log::Log for JournalLogger {
	fn enabled(&self, metadata: &Metadata) -> bool {
		metadata.level() <= self.level
	}

	fn log(&self, record: &Record) {
		if self.enabled(record.metadata()) {
			let mut sd_record = Vec::with_capacity(7);

			sd_record.push(format!("PRIORITY={}",
				match record.metadata().level() {
					Level::Debug => Priority::Debug,
					Level::Trace => Priority::Debug,
					Level::Info => Priority::Info,
					Level::Warn => Priority::Warning,
					Level::Error => Priority::Error
				} as u8
			));

			sd_record.push(format!("MESSAGE={}", record.args()));
			if let Some(file) = record.file() {
				if !file.is_empty() {
					sd_record.push(format!("CODE_FILE={}", file));
					if let Some(line) = record.line() { sd_record.push(format!("CODE_LINE={}", line)) };
				}
			}

			if let Some(module_path) = record.module_path() { if !module_path.is_empty() { sd_record.push(format!("MODULE_PATH={}", module_path)) } };
			if !record.target().is_empty() { sd_record.push(format!("SYSLOG_IDENTIFIER={}", record.target())) };

			let iovecs: Vec<iovec> = sd_record.iter().map(|v| {
				iovec {
					iov_base: v.as_ptr() as *const libc::c_void,
					iov_len: v.len() as libc::size_t
				}
			}).collect();

			unsafe {
				sd_journal_sendv(iovecs.as_ptr(), iovecs.len() as libc::c_int);
			}
		}
	}

	fn flush(&self) {
		// There is no flush for the journal.
	}
}

pub fn init_with_level(level: Level) -> Result<(), SetLoggerError> {
	log::set_boxed_logger(Box::new(JournalLogger {
		level
	}))?;

	log::set_max_level(level.to_level_filter());

	Ok(())
}

#[cfg(test)]
mod tests
{
	use super::*;

	#[test]
	fn layout_iovec() {
		// This test was adopted from the bindgen autogenerated tests.
		assert_eq!(std::mem::size_of::<iovec>(), 16usize, concat!("Size of: ", stringify!(iovec)));
		assert_eq!(std::mem::align_of::<iovec>(), 8usize, concat!("Alignment of ", stringify!(iovec)));
		assert_eq!(unsafe { & ( * (std::ptr::null::<iovec>())).iov_base as * const _ as usize }, 0usize, concat!("Offset of field: ", stringify!(iovec) , "::" , stringify!(iov_base)));
		assert_eq!(unsafe { & ( * (std::ptr::null::<iovec>())).iov_len as * const _ as usize }, 8usize, concat!("Offset of field: ", stringify!(iovec), "::" , stringify!(iov_len)));
	}
}